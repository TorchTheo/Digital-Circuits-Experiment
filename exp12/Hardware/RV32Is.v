
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module RV32Is(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

// vga normal
wire vga_clk, vga_clk_rst, vga_clk_en;
wire [24:0] vga_data;
wire [9:0] h_addr, v_addr;
wire hsync, vsync, vga_valid;
wire [7:0] vga_r, vga_g, vga_b;
reg [12:0] offset;
// vga index ctrl
reg [7:0] char_ind_x, char_ind_y;
reg [3:0] pixel_ind_x, pixel_ind_y;

// keyboard inout data
wire kb_clk, kb_clrn;
wire [7:0] scancode, asciicode;
wire kb_valid;
// cursor_ctrl
reg [7:0] cursor_x, cursor_y;
// color ctrl
//wire [23:0] colors[7:0];

// keyboard input buffer: queue
reg [7:0] kb_scancode_buffer[255:0];
reg [7:0] kb_asciicode_buffer[255:0];
reg [7:0] kb_w_ptr, kb_r_ptr;
wire [7:0] kb_asciicode, kb_scancode;
wire kb_ready;

// cpu rv32is's declarations
wire cpu_clk, cpu_rst, imemclk, dmemrdclk, dmemwrclk, dmemwe;
wire [2:0] dmemop;
wire [31:0] imemaddr, dmemaddr, dbgdata;
reg [31:0] imemdataout, memdataout;
wire [31:0] dmemdatain,dmemdataout;
//=======================================================
//  Structural coding
//=======================================================

wire [31:0]TIME;
Clock __clock(CLOCK_50,TIME);

// vga_clk generator
//clkgen #(25000000) vgaclk_gen(CLOCK_50, vga_clk_rst, vga_clk_en, VGA_CLK);
clkgen #(25000000) my_clk(CLOCK_50, 1'b0, 1'b1, VGA_CLK);
// vga
/*VGA_Ctrl vga_ctrl(
	.pclk(VGA_CLK),
	.reset(vga_clk_rst),
	.vga_data(vga_data),
	.h_addr(h_addr),
	.v_addr(v_addr),
	.hsync(VGA_HS),
	.vsync(VGA_VS),
	.valid(vga_valid),
	.vga_r(VGA_R),
	.vga_g(VGA_G),
	.vga_b(VGA_B),
	
	.ascii_ind_x(char_ind_x),
	.ascii_ind_y(char_ind_y),
	.pixel_ind_x(pixel_ind_x),
	.pixel_ind_y(pixel_ind_y)
);*/

vga_ctrl_ myvga(
	VGA_CLK, 
	1'b0, 
	vga_data, 
	h_addr, 
	v_addr, 
	VGA_HS, 
	VGA_VS, 
	VGA_BLANK_N, 
	VGA_R, 
	VGA_G, 
	VGA_B);

// vga mem to vga data
/*VGA_Mem vga_mem(
	.clk(~CLOCK_50),
	.rstn(~vga_clk_rst),
	.wren(dmemwe && (dmemaddr[31:20] == 12'h2)),
	.w_ascii_addr_x(cursor_x),
	.w_ascii_addr_y(cursor_y),
	.w_ascii(dmemdatain[7:0]),
	.r_ascii_addr_x(char_ind_x),
	.r_ascii_addr_y(char_ind_y),
	.r_ascii_pixel_x(pixel_ind_x),
	.r_ascii_pixel_y(pixel_ind_y),
	.vga_data(vga_data)
);*/

vga_ myxiancun(
	~CLOCK2_50,
	VGA_CLK,
	VGA_BLANK_N,
	h_addr,
	v_addr,
	dmemdatain[7:0],
	dmemaddr[31:0],
	~dmemwrclk,
	(dmemwe && (dmemaddr[31:20] == 12'h2)),
	offset,
	vga_data);

// vga ctrl signals
//assign vga_clk_rst = ~KEY[0];
assign vga_clk_rst = 0;
//assign vga_clk_en = SW[0];
assign vga_clk_en = 1;

// vga settings
assign VGA_SYNC_N = 1'b0;
//assign VGA_BLANK_N = vga_valid;
//assign VGA_CLK = vga_clk;
//assign VGA_HS = hsync;
//assign VGA_VS = vsync;
//assign VGA_R = (vga_r != 8'h0 ? 8'hff : 8'h0);
//assign VGA_G = (vga_b != 8'h0 ? 8'hff : 8'h0);
//assign VGA_B = (vga_g != 8'h0 ? 8'hff : 8'h0);
//assign VGA_R = vga_r;
//assign VGA_G = vga_g;
//assign VGA_B = vga_b;


// keyboard signals
assign kb_clk = CLOCK_50;
assign kb_clrn = KEY[1];
//assign kb_clrn = 1;

// keyboard
keyboard kb(
	.clk(kb_clk), 
	.clrn(kb_clrn), 
	.ps2_clk(PS2_CLK), 
	.ps2_data(PS2_DAT), 
	.cur_key(scancode), 
	.ascii_key(asciicode), 
	.valid(kb_valid)
);

// Keyboard Input Buffer
assign kb_asciicode = kb_asciicode_buffer[kb_r_ptr];

initial begin
	kb_w_ptr <= 0;
	kb_r_ptr <= 0;
end

assign kb_ready = (kb_w_ptr != kb_r_ptr);

always @(negedge kb_clk) begin
	if(kb_valid) begin // if overflow stop writing
		kb_asciicode_buffer[kb_w_ptr] <= asciicode;
		kb_w_ptr <= kb_w_ptr + 1;
	end
end


// cpu rv32is
rv32i_jg rv32is(
	.clock(cpu_clk),
	.reset(cpu_rst),
	.imemaddr(imemaddr),
	.imemdataout(imemdataout),
	.imemclk(imemclk),
	.dmemaddr(dmemaddr),
	.dmemdataout(memdataout),
	.dmemdatain(dmemdatain),
	.dmemrdclk(dmemrdclk),
	.dmemwrclk(dmemwrclk),
	.dmemop(dmemop),
	.dmemwe(dmemwe),
	.dbgdata(dbgdata)
);

// cpu_clk generator
clkgen #(25000000) cpu_clk_gen(CLOCK_50, cpu_rst, 1'b1, cpu_clk);
assign cpu_rst = ~KEY[0];

INSTRMEM imem(
	.address(imemaddr[15:2]),
	.clock(imemclk),
	.q(imemdataout[31:0])
);

Data_Mem dmem(
	.addr(dmemaddr[31:0]),
	.datain(dmemdatain[31:0]),
	.dataout(dmemdataout[31:0]),
	.rdclk(~CLOCK_50),
	.wrclk(dmemwrclk),
	.memop(dmemop),
	.we(dmemwe && (dmemaddr[31:20] == 12'h1))
);

/*wire [3:0]byteena_a;
assign byteena_a[3:0] = (dmemop==3'b000)? 4'b0001 : (dmemop==3'b001)? 4'b0011 : (dmemop==3'b010)? 4'b1111 : 4'b0000;
dmem md(
	byteena_a,
	dmemdatain[31:0],
	dmemaddr[31:0],
	~CLOCK_50,
	dmemaddr[31:0],
	dmemwrclk,
	dmemwe && (dmemaddr[31:20] == 12'h1),
	dmemdataout[31:0]);*/

always @(*) begin
	case(dmemaddr[31:20]) 
		12'h0: begin
		end
		12'h1: begin
			memdataout <= dmemdataout;
		end
		12'h2: begin
			if(dmemwe) begin
				cursor_x <= dmemaddr[6:0];
				cursor_y <= dmemaddr[13:7];
			end
		end
		12'h3: begin
			case(dmemaddr[19:0])
				20'h0: begin
					memdataout <= kb_asciicode;
				end
				20'h1: begin
					memdataout <= kb_r_ptr[7:0];
				end
				20'h2: begin
					memdataout <= kb_w_ptr[7:0];
				end
			endcase
		end
		12'h4: begin
				memdataout <= TIME[31:0];
			end
		12'h100: begin
			memdataout <= offset;
		end
		default: begin
		end
	endcase
end

always @(negedge dmemwrclk) begin
	if(dmemwe) begin
		case(dmemaddr[31:20])
			12'h3: begin
				case(dmemaddr[19:0])
					20'h1: begin
						kb_r_ptr <= dmemdatain[7:0];
					end
				endcase
			end
			12'h100:begin
				offset <= dmemdatain[12:0];
			end
		endcase
	end
end

bcd2seg hex0(
	.b(kb_w_ptr[3:0]),
	.en(1'b1),
	.h(HEX0)
);
bcd2seg hex1(
	.b(kb_w_ptr[7:4]),
	.en(1'b1),
	.h(HEX1)
);
bcd2seg hex2(
	.b(kb_r_ptr[3:0]),
	.en(1'b1),
	.h(HEX2)
);
bcd2seg hex3(
	.b(kb_r_ptr[7:4]),
	.en(1'b1),
	.h(HEX3)
);
bcd2seg hex4(
	.b(offset[3:0]),
	.en(1'b1),
	.h(HEX4)
);
bcd2seg hex5(
	.b(offset[7:4]),
	.en(1'b1),
	.h(HEX5)
);

assign LEDR[0] = kb_valid;

endmodule
